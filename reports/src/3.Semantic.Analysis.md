---
title: Semantic Analysis
author: Sungbin Jo (2021-13630), Kijun Shin (2021-15391)
---

## CppSnuPL implementation notes

In Phase 3, we have many choices during implementation, such as separation of semantic check logic, parsing negative integers, etc. Unlike Phase 2, some logic implementation aren't quite strightforward. We are going to explain our choice and details of current implementation here.

## Notable differences from the provided code

First, these are some important decision of CppSnuPL:
- prohibit implicit integer/longint conversion
- usage of strict constant folding

And some decisions made during implement specific semantic rules:
- Array subscription is only allowed with `integer` type. `longint` type isn't allowed.
- String constant declaration is only way to initialize array type. Conversely, it means that we can evaluate though some char constant's initial value is defined by subscript on string. It will be compiled successfully.
- When compiler meets overflow during integer/longint constant evaluation, it will keep calculate it and gives overflowed result to `CDataInitializer`.

### Semantic Rule Checklist

There are many semantic rules which can't be described in EBNF form or Regex. So these have to be managed manually. List below is what we consider:

- Type Checking
  - compatible type at binary, unary operator
  - compatible type at assignment, declaration
  - boolean expression on if, while statement
  - integer/longint range check
  - Procedure/Function
    - compatible declaration, return type
    - compatible parameter, argument type(and same number)
  - Array
    - dimension/int type check on subscript
    - size must be provided in declaration
- Constant Evaluation
- Valid Identifier
  - duplicate declaration in same scope
  - invalid(undefined) symbol
  - Module/Subroutine: identifier match
- SnuPL/2 specific issues
  - prohibit use of composite type in return and assign
  - prohibit subarray argument
  - implicit type conversion of array parameter, argument

We checks some of semantic analysis in parsing phase. However, it is more natural that semantic analysis is operated on 'ast.cpp', we tried to do semantic analysis on 'ast.cpp'.

List below is what parsing phase checks:

- integer/longint range check: To easily parse decimal(or somewhat else) represented int type constant, `strtoll` function is recommended. So performing range check instantly after recognize constant value is convenient.
```c++
errno = 0;
long long v = strtoll(t.GetValue().c_str(), NULL, 10);
if (errno != 0) SetError(t, "Invalid number.");

if (t.GetValue().back() != 'L' && v > INT_MAX) {
  SetError(t, "Overflow in integer constant.");
}
```
- return type check: Checking whether return type of function is scalar type is determined by only one expression, which can easily caught by parser.
- duplicate identifier on declaration: Dividing symbol table managing logic and checking duplicate identifier logic is seemed unnecessary. We checks it on parser include parameter declaration. In general it can be done with find symbol before adding, but exception exists on checking function/procedure parameter duplication. It's because parameters are inserted to symbol table at once, not immediately after consuming token related to them.
```c++
set<string> param_set;
for (CSymParam *param : params) {
  if (param_set.find(param->GetName()) != param_set.end()) {
    SetError(t, "Duplicated parameter: " + param->GetName());
  }
  sym->AddParam(param);
  param_set.insert(param->GetName());
}
```
- 

### Type Checking

To implement type checking, 4 important methods `GetType()`, `TypeCheck()`, `Match(`, `Compare()` have to be completed. In many cases, type or type's validity depends on recursive function call result. According to method's purpose, `TypeCheck()` method return `false` immediately when they meet error on child, so they don't modify error message. `GetType()` return `NULL` immediately. 

Operation of `Match()` and `Compare()` on scalar type is trivial. On array, `Match()` return false only when two array `_nelem` is finite and different. On pointer, `Match()` return result of `Match()` of dereferred value. Implementation of `Compare()` isn't that important since we use `Compare()` method only in `CTypeManager::GetPointer()`/`CTypeManager::GetArray()`. The 'real' comparison happened on `Match()`.

```c++
bool CArrayType::Match(const CType *t) const
{
  if ((t == NULL) || !t->IsArray()) return false;

  const CArrayType *at = dynamic_cast<const CArrayType *>(t);
  assert(at != NULL);

  if (GetNElem() == OPEN || at->GetNElem() == OPEN || GetNElem() == at->GetNElem()) {
    return GetInnerType()->Match(at->GetInnerType());
  }
  return false;
}

bool CPointerType::Match(const CType *t) const
{
  if ((t == NULL) || !t->IsPointer()) return false;

  const CPointerType *pt = dynamic_cast<const CPointerType *>(t);
  assert(pt != NULL);

  if (!GetBaseType() || GetBaseType()->Match(pt->GetBaseType())) return true;

  return false;
}
```

Implementation of `TypeCheck()` method of binary, unary operator is pretty straightforward. In case of `CAstSpecialOp::TypeCheck()`, when operation is `opCast`, `opWiden`, or `opNarrow`, it will be true logically. However we don't allow implicit type conversion so make `assert(false)` to it. `opAddress` is always true, and `opDeref` checks only if given type is pointer type.

```c++
bool CAstSpecialOp::TypeCheck(CToken *t, string *msg)
{
  const CType *type = GetOperand()->GetType();
  EOperation oper = GetOperation();

  switch (oper) {
    case opAddress:
      return true;
    case opDeref:
      if (!type->IsPointer()) {
        if (t != NULL) *t = GetToken();
        if (msg != NULL) *msg = "Cannot dereference non-pointer type.";
        return false;
      }
      return dynamic_cast<const CPointerType *>(type)->GetBaseType() != nullptr;
    case opCast:
    case opWiden:
    case opNarrow:
      assert(false);
      return true;
    default:
      assert(false);
      return false;
  }
}
```




### Handling implicit array-pointer conversion

Every array-typed parameter in parameters are passed as pointers. The
CppSnuPL handles these conversions during parsing and parses array
parameters as pointers; an implicit addressof (the `&` special
operation) is inserted by the parser when passing arrays to
subroutines.

## Notable differences from the provided code

### Parser has two token lookahead

To distinguish between an assignment and a subroutine call or between
an array subscript and a subroutine call, the parser must know the
token after the leading identifier. The suggested design was to pass
the first token to each parsing function, but it felt quite hackish.

Instead, we saw that the parser already had an interal `_token` field
that isn’t used anywhere in the skeleton code. We modified the
`Consume()` method to stash the new token to the `_token`, updated
`Peek()` and created `PeekNext()` appropriately.

## SwiftSnuPL: An experimental Swift port of SnuPL

### Motivation

The unfamiliarity on the C++ language pushed us to experiment with
porting the compiler to a more familiar language.

Partially porting the parser to Swift showed a significant
productivity increase not only from familiarity but also from the
conciseness of the language, algebric data types, and pattern
matching.

We decided to use the Swift port as a sandbox for experimenting with
various design deviations from the original design.

## SwiftSnuPL design notes

Below are some parser design deviations from the original skeleton
code:

- The AST produced by the parser is a dumb interpretation of the
  provided code.
  - Any implicit casts or conversions are not represented in the AST.
  - The parser doesn’t have knowledge on symbol resolution or types.

- Symbol resolution and type checking is done in a resolve stage
  separate from parsing, and produces a side table outside of the
  AST that contains symbol and type information.
  - We’re not confident with this design decision; we are not sure if
    this will play out as expected when implementing the TAC
    generator.

## SwiftSnuPL design and implementation notes

### Model the AST as dumb sum types instead of subclasses

In our opinion, this encodes more naturally in code. This also allows
separating logic between stages are easier: we can pattern match the
AST nodes outside of the AST implementation, instead of relying on the
langauge’s dynamic dispatch. (Arguably this is just as possible with
implementing something like a visitor pattern, but this is even more
verbose.)

- Have the types `Expression`, `Statement`, `Type`, `Declaration` as a
  sum type (enumerations with associated values in Swift speech)
  - The target of an `.assignment` is an `Expression` for future
    extensions. (The parser only parses targets)
- Generates a complete parse tree without considering any

### Reuse of the CppSnuPL scanner

Thanks to the Swift’s C interop feature, we can reuse the C++
implementation of the scanner. The SPM target `CppSnuPL` and
`SwiftSnuPL/Scanner.swift` implements the scanner.

Off-topic, but this feature was pretty cool: throw in some C header
files, and the embbedded clang in the Swift compiler can transparently
import functions.

### Testing by pretty-printing

We have added a pretty printer PoC that allows regenerating compatible
SnuPL code from the parsed module. We’ve found some parser bugs by
parsing test cases, pretty printing, reparsing the code and comparing
the results.

- Have implemented a complete `Parser` and `Resolver`, a
  `TACGenerator` PoC is also implemented.

- Added a pretty printer PoC that allows regenerating compatible SnuPL code
  - Testing the parser by parsing, pprinting and reparsing, and comparing the results


### Implemented types and grammar of `Parser`

Below are the Swift types used to represent the AST.

Most are boring; one interesting point is that the AST represents
subroutines in calls and assignment targets as a generic `Expression`
instead of an identifier. The parser currently rejects any code that
doesn’t call a single identifier (and the resolver rejects while type
checking as well), but future language extensions might allow more
expressions (like an item of array of functions) to be callable as
well.

```swift
indirect enum Expression {
    case unary(`operator`: Token, value: Expression)
    case binary(`operator`: Token, `left`: Expression, `right`: Expression)
    case `subscript`(array: Expression, index: Expression)
    case call(function: Expression, arguments: [Expression])
    case variable(name: Token)
    case integer(Int32)
    case longint(Int64)
    case boolean(Bool)
    case char(UInt8)
    case string([UInt8])
}

indirect enum Statement {
    case assignment(target: Expression, value: Expression)
    case call(procedure: Expression, arguments: [Expression])
    case `if`(condition: Expression, thenBody: [Statement], elseBody: [Statement])
    case `while`(condition: Expression, body: [Statement])
    case `return`(value: Expression?)
}

indirect enum `Type` {
    case boolean
    case char
    case integer
    case longint
    case array(base: `Type`, size: Expression?)
}

struct Parameter {
    let name: Token
    let type: `Type`
}

indirect enum Declaration {
    case `var`(name: Token, type: `Type`)
    case `const`(name: Token, type: `Type`, initializer: Expression)
    case procedure(name: Token, parameters: [Parameter], block: Block?)
    case function(name: Token, parameters: [Parameter], `return`: `Type`, block: Block?)
}

struct Module {
    let name: Token
    let block: Block
}

struct Block {
    let declarations: [Declaration]
    let body: [Statement]
}
```

Below is the equivalent SnuPL grammar as implemented in the Swift
parser. Comments indicate the parser function that implemented the
associated grammar.

```ebnf
(* parseModule() *)
module = "module" ident ";"
         { constDeclarations | varDeclarations | functionDeclaration | procedureDeclaration }
         [ "begin" statements ] "end" ident "." ;

(* Declarations *)
(* parseVarDeclarations() -> [Declaration] *)
varDeclarations = "var" varDeclaration ";" { varDeclaration ";" } ;
varDeclaration = ident { "," ident } ":" type ;

(* parseConstDeclarations() -> [Declaration] *)
constDeclarations = "const" constDeclaration ";" { constDeclaration ";" } ;
constDeclaration = ident { "," ident } ":" type "=" expression ;

(* parseFunctionDeclaration() -> Declaration *)
functionDeclaration = "function" ident [ parameters ] ":" type ";"
                      ( "extern" | functionBody ident ) ";" ;
functionBody = [ constDeclarations ] [ varDeclarations ] "begin" statements "end" ;

(* parseProcedureDeclaration() -> Declaration *)
procedureDeclaration = "procedure" ident [ parameters ] ";"
                       ( "extern" | procedureBody ident ) ";" ;
procedureBody = [ constDeclarations ] [ varDeclarations ] "begin" statements "end" ;

(* parseParameters() -> [Parameter] *)
parameters = "(" parameterDeclarations ")" ;
parameterDeclarations = [ parameterDeclaration { ";" parameterDeclaration } ] ;
parameterDeclaration = ident { "," ident } ":" type ;

(* Statements *)
statements = [ statement { ";" statement } ] ;                                  (* parseStatements() -> [Statement] *)
statement = assignment | procedureCall | if | while | return ;                  (* parseStatement() -> Statement *)
assignment = subscript ":=" expression ;                                        (* parseAssignment(target: Expression) -> Statement *)
procedureCall = ident "(" [ expression { "," expression } ] ")" ;               (* parseProcedureCall(procedure: Expression) -> Statement *)
if = "if" "(" expression ")" "then" statements [ "else" statements ] "end" ;    (* parseIf() -> Statement *)
while = "while" "(" expression ")" "do" statements "end" ;                      (* parseWhile() -> Statement *)
return = "return" [ expression ] ;                                              (* parseReturn() -> Statement *)

(* Types *)
type = baseType { "[" [ plusMinus ] "]" } ;             (* parseType() -> `Type` *)
baseType = "boolean" | "char" | "integer" | "longint" ; (* parseBaseType() -> `Type` *)

(* Expressions *)
expression = relation ;                                                             (* parseExpression() -> Expression *)
relation = plusMinus [ ( "=" | "#" | "<" | "<=" | ">" | ">=" ) plusMinus ] ;        (* parseRelation() -> Expression *)
plusMinus = [ "+" | "-" ] mulDiv { ( "+" | "-" | "||" ) mulDiv } ;                  (* parsePlusMinus() -> Expression *)
mulDiv = primary { ( "*" | "/" | "&&" ) primary } ;                                 (* parseMulDiv() -> Expression *)
primary = subscript | literal | "(" expression ")" | functionCall | "!" primary ;   (* parsePrimary() -> Expression *)
literal = number | boolean | char | string ;                                        (* parseLiteral() -> Expression *)
subscript = variable [ "[" plusMinus "]" ] ;                                        (* parseSubscript() -> Expression *)
functionCall = variable "(" [ expression { "," expression } ] ")" ;                 (* parseFunctionCall() -> Expression *)
variable = ident ;                                                                  (* parseVariable() -> Expression *)
```

### Implementation notes on `Resolver`

FYI to the reader: the `Resolver.swift` is not yet committed to the
repository at the time of writing. It will be pushed soon.

The resolver resolves symbols and type-checks the code. It maintains a
separate side table with a type mapping for each subexpression in the
parse tree, and a symbol mapping for each token that represents a
variable.

The resolver introduces new types to represent types, symbols and
scopes as below.

```swift
indirect enum `Type` {
    case boolean
    case char
    case integer
    case longint
    case array(base: `Type`?, size: Int32?)
    case procedure(parameters: [`Type`])
    case function(parameters: [`Type`], `return`: `Type`)

    var isScalar: Bool { /* … */ }
    func isAssignable(to target: Self) -> Bool { /* … */ }
    func isConvertible(to target: Self) -> Bool { /* … */ }
}

enum Symbol {
    case `var`(token: Token, type: `Type`)
    case const(token: Token, type: `Type`, initializer: AnyHashable)
}

struct Scope {
    var symbols: Set<Symbol>
    let `return`: `Type`?

    mutating func addVar(token: Token, type: `Type`) { /* … */ }
    mutating func addConst(token: Token, type: `Type`, initializer: AnyHashable) { /* … */ }
    func findSymbol(named name: String) -> Symbol? { /* … */ }
}
```

The resolver uses a separate type different from `Parser.Type` for
representing internal types, including procedure and function types as
well as an array without type restrictions (anyarray), used for the
`DIMS` and `DOFS` internal functions (anyarrays are represented as
`.array(base: nil, size: nil)`).
