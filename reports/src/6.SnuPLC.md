---
title: SwiftSnuPL: A Swift/ARM64 version of the SnuPL compiler
author: Sungbin Jo (2021-13630), Kijun Shin (2021-15391)
---

## Introduction

We have rewrote the SnuPL compiler in the Swift language.

### Motivation

The unfamiliarity on the C++ language pushed us to experiment with
porting the compiler to a more familiar language.

Partially porting the parser to Swift showed a significant
productivity increase not only from familiarity but also from the
conciseness of the language, algebric data types, and pattern
matching.

We decided to use the Swift port as a sandbox for experimenting with
various design deviations from the original design.

### Design Goals

The following were the goals when starting the rewrite:

- Each phase has a component that is responsible for it.
- These components must communicate with plain data structures that do
  not have any behavioral knowledge of phases.
- To report multiple errors, each phase tries hard enough to make
  something, with a list of encountered errors.

While these goals were not totally achieved, we believe that

### Data Structures

The tokens

### Known Problems / Possible Improvements

The biggest known problem is that the `Resolver` does not do any error
handling in its current form. While the appropriate functions are
marked throwing, and basically.

## Syntax Analysis

The parser is a simple LL(1) parser.

## Phase 3: Semantic Analysis

The `Resolver` of SwiftSnuPL has two responsibilities:

- Resolving the tokens to the appropriate symbols
- Calculating the types of various expressions

Notably, instead of the parser resolving the symbols during parsing,
we handle symbol resolving in phase 3.

As SwiftSnuPL has static scoping rules, the notion of scopes do not
have to exist outside of the `Resolver`; it maintains an internal
stack of scopes during resolving, and the scopes do not have any
presence after this phase.

Scopes contain multiple `Symbol`s,

To support `const` symbols, the `Resolver` implements a simple
compile-time evaluator. Since the `Parser` only allows a separate

SwiftSnuPL also completes phase 3. The SwiftSnuPL Resolver handles
both symbol resolving and type checking, covering a subset of phase 2
and phase 3. The Resolver saves type and symbol information on an side
table separately from the parser AST. This not only allows the parser
to continue and parse the code, and report resolver errors in a batch,
but also allows centralizing resolving and type checking logic. The
resolver finally produces a map of AST nodes to type information and
resolved Symbols.


## Intermediate Code Generation
